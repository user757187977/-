### synchronized
1. synchronize 是 java 的关键字, 可以用来修改代码块, 方法
2. 通过反编译可以看到其根本原理就是monitor enter和monitor exit来控制的，monitor就是c++调用cpu的两个指令，monitor也有计数器，当为0的时候执行 monitor enter，不为0时候等待，进入了+1，离开-1
3. 被加载到 jvm 中的每个实例都有一个对象头, 其中对象头中包含着 32 位的存储单元, 其中就保存了 monitor 信息与锁状态.
4. synchronize 也对应有着优化:
   1. 偏向锁：当锁对象第一次被线程A获取时，虚拟机将会把对象头中的标志位设为可偏向，是否偏向锁置为1，锁对象与线程A绑定偏向锁，当下一次A线程再参与竞争时，对象偏向被线程A锁住；就相当于尝试获取锁的第一句话就是找对象的偏向锁之后和当前线程比较，成功了把锁给线程A，失败了，取消偏向锁；
   2. 轻量级锁：就是自旋锁+CAS；CAS尝试修改对象头的markword中心的信息，
   3. 那么自旋又是什么意思呢，就是在许多场景下，需要加锁执行的代码是执行很快的，那么我只需要线程死循环一会来获取锁就可以避免阻塞了，JDK6中叫适应性自旋锁，怎么适应性呢，就是死循环的次数是由上一次线程获取锁时自旋的次数。
### volatile
### Lock 接口
1. 如果实现的可重入:
   1. 定义一个 state, 
### synchronized 与 Lock 的区别
1. synchronized 为 java 自带的关键字, Lock 是基于语言实现的一个接口.
2. 性能上, 差距并不大, 但是 Lock 毕竟是基于 CAS 实现, 极端性能上由于 synchronized.
3. Lock 的使用全程由用户手动调用, tryLock() unlock(), 包括即便是异常情况下, 也仍然需要用户手动释放.
4. synchronized 可重入, 非公平; Lock 可重入, 可公平或者非公平.
   1. 解释下什么叫可重入锁: 如果两个线程同时对同一个锁进行加锁操作, 就会产生死锁的现象, 重入锁就是为了解决这样的场景. 