1. 在 [Java Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se8/html/) 中, 搜索 heap, 就会发现 ![img.png](img.png)
2. 在第二章, 有一个 Run-Time Data Areas, 其中定义了:
   1. The pc(program counter) Register(程序计数器) 
   2. Java Virtual Machine Stacks(JVM 栈)
   3. Heap(堆)
   4. Method Area(方法区)
   5. Run-Time Constant Pool(运行时常量池)
   6. Native Method Stacks(本地方法栈)    
   `到这, 可能很多人懵了, 诶, 怎么定义了 6 个区域呢, 网上明明写着 5 个呢? 其实是: 因为这个运行时常量池是保存在方法区中的, 所以很多人都用方法区来概括这个运行时常量池`
3. 规范由 Oracle 定义了, 总得实现这套规范, 谁实现的呢? **HotSpot** 那么我们说的这些 永久代 老年代 这些, 都是 HotSpot 的实现. 不要和 JVM 虚拟机规范混为一谈.
4. HotSpot 如何实现 JVM 规范: ![img_1.png](img_1.png) 其中堆和方法区是线程共享, 其他均为线程私有.
   1. 堆区: HotSpot 使用新生代(Eden区, From Survivor, To Survivor) 老年代来实现堆区, 新生代：老年代=1：2，新生代：包括Eden，From S，To S区，比例是8：1：1，对象都会再Eden区创建出来的，E满了之后进行一次轻GC，存活对象放入到F，这个阶段相当于E与F协同，当F满了之后对E与F进行轻GC，存活对象存放到T，这个阶段变成了E与T区协同工作，当一个对象经过15次GC还没有消亡，就存放老年代，老年代满了就进行Full GC，Full是对整个堆空间进行的GC；
      Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生
      设置两个Survivor区最大的好处就是解决了碎片化
   2. 方法区: 类的元数据, 构造函数, 是接口还是 class, 加载器是哪个...
   3. JVM 栈: 随着线程的创建, 便创建出栈帧, 放入到 JVM 栈中, 栈帧中存放着局部变量 操作树栈 方法出口等.
   5. 本地方法栈: Native 方法的运行空间.
   4. 程序计数器: 每个线程都有自己的程序计数器. 
5. JVM 中定义的方法区, 在不同版本 jdk 的实现是不同的, jdk7 是通过永久代来实现的, jdk8 废除永久代使用元空间来实现.
   1. jdk8 的特点不仅仅只是改成了元空间这个名字而已, 重要的是对方法区的实现, 改成了使用堆外内存来保存类的元数据(schema), 这么做的好处就是, 随着年代的变更, 内存的单位价钱也在下降, 大家有着更多的物理内存, 而依靠我们的经验, 大家分配给 JAVA 进程的内存并不是非常多的, 所以把有限的 java 进程内存节省出来, 放到性价比更高的物理内存中, 以达到减少 GC 次数的优点.
6. HotSpot 除了实现内存的规划, 还有对字节码(Class 文件)加载的实现, 我们常说的 加载过程 和 双亲委派模型就是在这里实现的:
   1. 加载过程
   2. 双亲委派模型：
      1. 首先类加载器是有一个类似 继承 关系的概念, Application ClassLoader -> Extension ClassLoader -> Bootstrap ClassLoader, 每个类加载器负责一个指定目录下的类库加载. 
      2. 在这个模型中, 有一个核心思想就是，如果可以用父类加载器，那就用父类加载器, 只有父类加载器无法完成家在请求, 才向下传递. 
   3. 双亲委派的意义: 避免重复加载 & 沙箱保护机制, 比如我们自己定义一个 String 类, 实现一个 main 方法, 最终被加载的其实是 java.lang.String, 而这个 String 类是没有 main 函数的.  
7. 有了加载, 就得有回收, 如何判断对象可以回收?
   1. 引用计数法(已废弃)
   2. 可达性分析(根引用), 从 GcRoot 向下染色, 便可以得到哪些对象有引用, 哪些没有, 虚拟机则对应判断是否回收. 其中 GcRoot 包含了:
      1. JVM 栈 本地方法栈 中引用的对象
      2. 方法区中常量和静态属性引用的对象
   3. 不同类型引用:
      1. 强引用, 平时常用的 new 对象创建出来的都是强引用, 意味着宁愿 OOM 也不要回收.
      2. 弱引用, 只要 GC 就回收弱引用对象
      3. 软引用, 当发现快要 OOM 时, 回收软引用
      4. 虚引用, 随时可以回收
8. 那么可以判断哪些对象可以回收之后, 垃圾回收算法都有哪些呢?
   1. 标记清除: 一个染色过程, 就是 GcRoot 向下染色
   2. 复制算法: 把内存一分为二, 比如 ab 两个区域, 使用其中一部分a, 然后将存活的对象复制到另外一部分b, 然后整体清除a
   3. 标记整理: 也是先标记对象, 但是后续并不是立即清除, 而是将所有存活对象向下一段内存空间移动, 然后清除这段内存空间边界外的区域.
   4. 目前虚拟机使用的是分代收集, 不同代适用于不同的回收方式, 新生代存活率低, 使用复制算法, 清除高效. 老年代存活率高, 要节省内存的利用, 没有额外的空间进行分配, 所以标记清除或者标记整理.
9. 有哪些垃圾回收器? 
   1. 在 G1 之前呢, 一共有 7 种回收器, 分别对应不同代的内存回收场景, 在解释这些具体的回收器之前, 先解释几个概念:
      1. 并行: 多个回收线程一起工作, 此时用户线程全部等待.
      2. 并发: 回收线程与用户线程同时执行.
   2. 总之呢, 不管哪个回收器, 都离不开这几种类型, 单线程、并行、并发回收器.
   3. 详细解释下 CMS: 是一个并发处理机制, 基于“标记-清除”算法实现的, 详细的执行过程:
      1. 初始标记：暂停所有的其他线程，并记录下直接与root相连的对象；
      2. 并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
      3. 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。
      4. 并发清除：开启用户线程，同时GC线程开始对为标记的区域做清扫。
   4. 详细解释下 G1: 特点是并发与并行
      1. G1的目标就是: 利用多核减少 STW 的时长, 小区域收集 + 形成连续的内存块（避免内存碎片）
      2. 首先看看 G1 的回收模型: 不同于其他的回收器将堆分成了各种代, 取而代之的是 G1 管理了整个堆区的回收, 将堆区分割不同的区域, 可能第一块是Eden，第二块是Survivor(幸存区), 第三块是老年代, 第四五六块可能就是大对象. 类似于棋盘一样, 然后并发操作.
      3. G1 的回收步骤是怎么样的? 这个回收过程是围绕目标进行的, 其中一个目标就是形成连续的内存块, 一起都移动到一个小格子里成为一个新的S区，而且这个S区的位置集中这样可以避免内存碎片;
      4. G1还有一个牛逼的地方，可以设置期望停顿的时间；
10. 