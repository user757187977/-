### CPU usage vs CPU load

1. CPU usage: cpu 利用率, 程序对 CPU 时间片的占用情况.
2. CPU load: 表示 CPU 的负载, 是一段时间内 CPU 正在处理以及等待 CPU 处理的进程数之和的统计信息. 可以说是 CPU 使用队列的长度统计信息.

### 什么时候出现 CPU load 高

1. 需要 CPU 参与的线程数过高, 而 CPU 核心较少, 用于 CPU 上下文切换的时间已经高于执行时间.
2. 比如单核心 CPU 场景, 使用多线程进行 死循环i++ 操作.

### 什么时候 full GC

### 内存泄露遇到没

1. 先说什么才是内存泄露
2. 我们有哪些线索可以说明, 此刻我们遇到了内存泄露的问题
3. 内存泄露的解决办法

### 设计模式

### 线上问题
1. arthas 打火焰图
   1. profiler start --event itimer 由于 k8s 的 perf_event_open 默认是未开启的状态, 在容器内使用会有权限问题. 此时可以使用 itimer 事件来采样, 此事件与
   cpu 采样类似, 但是不需要 perf_events 支持, 缺点是无法统计内核的堆栈性能. 
   2. 火焰图 Y 轴: 表示 栈 深度, X 轴: 抽样数, 如果一个函数在 x 轴占据的宽度越宽, 就表示它被抽到的次数多, 即执行的时间长. 注意, x轴不代表时间, 而是所有的调用栈合并后, 按字母顺序排列的.  
   3. 火焰图就是看顶层的哪个函数占据的宽度最大. 只要有平顶 (plateaus), 就表示该函数可能存在性能问题.  颜色没有实际意义, 只是随机选取用于栈帧之间相互区分. 

